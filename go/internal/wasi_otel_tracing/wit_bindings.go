// Generated by `wit-bindgen` 0.51.0. DO NOT EDIT!
//
// This code was generated from the following packages:
//     wasi:io@0.2.0
//     wasi:clocks@0.2.0
//     wasi:otel@0.2.0-draft

package wasi_otel_tracing

import (
	"github.com/bytecodealliance/wit-bindgen/wit_runtime"
	"github.com/bytecodealliance/wit-bindgen/wit_types"
	"github.com/calebschoepp/opentelemetry-wasi/internal/wasi_clocks_wall_clock"
	"github.com/calebschoepp/opentelemetry-wasi/internal/wasi_otel_types"
	"runtime"
	"unsafe"
)

type Datetime = wasi_clocks_wall_clock.Datetime
type KeyValue = wasi_otel_types.KeyValue
type InstrumentationScope = wasi_otel_types.InstrumentationScope

// The trace that this `span-context` belongs to.
//
// 16 bytes encoded as a hexadecimal string.
type TraceId = string

// The id of this `span-context`.
//
// 8 bytes encoded as a hexadecimal string.
type SpanId = string

const (
	// Whether the `span` should be sampled or not.
	TraceFlagsSampled uint8 = 1 << 0
)

// Flags that can be set on a `span-context`.
type TraceFlags = uint8

// Carries system-specific configuration data, represented as a list of key-value pairs. `trace-state` allows multiple tracing systems to participate in the same trace.
//
// If any invalid keys or values are provided then the `trace-state` will be treated as an empty list.
type TraceState = []wit_types.Tuple2[string, string]

// Identifying trace information about a span that can be serialized and propagated.
type SpanContext struct {
	// The `trace-id` for this `span-context`.
	TraceId string
	// The `span-id` for this `span-context`.
	SpanId string
	// The `trace-flags` for this `span-context`.
	TraceFlags TraceFlags
	// Whether this `span-context` was propagated from a remote parent.
	IsRemote bool
	// The `trace-state` for this `span-context`.
	TraceState []wit_types.Tuple2[string, string]
}

const (
	// Indicates that the span describes a request to some remote service. This span is usually the parent of a remote server span and does not end until the response is received.
	SpanKindClient uint8 = 0
	// Indicates that the span covers server-side handling of a synchronous RPC or other remote request. This span is often the child of a remote client span that was expected to wait for a response.
	SpanKindServer uint8 = 1
	// Indicates that the span describes the initiators of an asynchronous request. This parent span will often end before the corresponding child consumer span, possibly even before the child span starts. In messaging scenarios with batching, tracing individual messages requires a new producer span per message to be created.
	SpanKindProducer uint8 = 2
	// Indicates that the span describes a child of an asynchronous consumer request.
	SpanKindConsumer uint8 = 3
	// Default value. Indicates that the span represents an internal operation within an application, as opposed to an operations with remote parents or children.
	SpanKindInternal uint8 = 4
)

// Describes the relationship between the Span, its parents, and its children in a trace.
type SpanKind = uint8

// An event describing a specific moment in time on a span and associated attributes.
type Event struct {
	// Event name.
	Name string
	// Event time.
	Time wasi_clocks_wall_clock.Datetime
	// Event attributes.
	Attributes []wasi_otel_types.KeyValue
}

// Describes a relationship to another `span`.
type Link struct {
	// Denotes which `span` to link to.
	SpanContext SpanContext
	// Attributes describing the link.
	Attributes []wasi_otel_types.KeyValue
}

const (
	// The default status.
	StatusUnset uint8 = 0
	// The operation has been validated by an Application developer or Operator to have completed successfully.
	StatusOk uint8 = 1
	// The operation contains an error with a description.
	StatusError uint8 = 2
)

// The `status` of a `span`.
type Status struct {
	tag   uint8
	value any
}

func (self Status) Tag() uint8 {
	return self.tag
}

func (self Status) Error() string {
	if self.tag != StatusError {
		panic("tag mismatch")
	}
	return self.value.(string)
}

func MakeStatusUnset() Status {
	return Status{StatusUnset, nil}
}
func MakeStatusOk() Status {
	return Status{StatusOk, nil}
}
func MakeStatusError(value string) Status {
	return Status{StatusError, value}
}

// The data associated with a span.
type SpanData struct {
	// Span context.
	SpanContext SpanContext
	// Span parent id.
	ParentSpanId string
	// Span kind.
	SpanKind SpanKind
	// Span name.
	Name string
	// Span start time.
	StartTime wasi_clocks_wall_clock.Datetime
	// Span end time.
	EndTime wasi_clocks_wall_clock.Datetime
	// Span attributes.
	Attributes []wasi_otel_types.KeyValue
	// Span events.
	Events []Event
	// Span Links.
	Links []Link
	// Span status.
	Status Status
	// Instrumentation scope that produced this span.
	InstrumentationScope wasi_otel_types.InstrumentationScope
	// Number of attributes dropped by the span due to limits being reached.
	DroppedAttributes uint32
	// Number of events dropped by the span due to limits being reached.
	DroppedEvents uint32
	// Number of links dropped by the span due to limits being reached.
	DroppedLinks uint32
}

//go:wasmimport wasi:otel/tracing@0.2.0-draft on-start
func wasm_import_on_start(arg0 uintptr, arg1 uint32, arg2 uintptr, arg3 uint32, arg4 int32, arg5 int32, arg6 uintptr, arg7 uint32)

func OnStart(context SpanContext) {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	utf8 := unsafe.Pointer(unsafe.StringData((context).TraceId))
	pinner.Pin(utf8)
	utf80 := unsafe.Pointer(unsafe.StringData((context).SpanId))
	pinner.Pin(utf80)
	var result int32
	if (context).IsRemote {
		result = 1
	} else {
		result = 0
	}
	slice := (context).TraceState
	length := uint32(len(slice))
	result3 := wit_runtime.Allocate(pinner, uintptr(length*(4*4)), 4)
	for index, element := range slice {
		base := unsafe.Add(result3, index*(4*4))
		utf81 := unsafe.Pointer(unsafe.StringData((element).F0))
		pinner.Pin(utf81)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).F0)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf81)))
		utf82 := unsafe.Pointer(unsafe.StringData((element).F1))
		pinner.Pin(utf82)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).F1)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf82)))

	}

	wasm_import_on_start(uintptr(utf8), uint32(len((context).TraceId)), uintptr(utf80), uint32(len((context).SpanId)), int32((context).TraceFlags), result, uintptr(result3), length)

}

//go:wasmimport wasi:otel/tracing@0.2.0-draft on-end
func wasm_import_on_end(arg0 uintptr)

func OnEnd(span SpanData) {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (40 + 32*4), 8))
	utf8 := unsafe.Pointer(unsafe.StringData(((span).SpanContext).TraceId))
	pinner.Pin(utf8)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4)) = uint32(uint32(len(((span).SpanContext).TraceId)))
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0)) = uint32(uintptr(uintptr(utf8)))
	utf80 := unsafe.Pointer(unsafe.StringData(((span).SpanContext).SpanId))
	pinner.Pin(utf80)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (3 * 4))) = uint32(uint32(len(((span).SpanContext).SpanId)))
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))) = uint32(uintptr(uintptr(utf80)))
	*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (4 * 4))) = int8(int32(((span).SpanContext).TraceFlags))
	var result int32
	if ((span).SpanContext).IsRemote {
		result = 1
	} else {
		result = 0
	}
	*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (1 + 4*4))) = int8(result)
	slice := ((span).SpanContext).TraceState
	length := uint32(len(slice))
	result3 := wit_runtime.Allocate(pinner, uintptr(length*(4*4)), 4)
	for index, element := range slice {
		base := unsafe.Add(result3, index*(4*4))
		utf81 := unsafe.Pointer(unsafe.StringData((element).F0))
		pinner.Pin(utf81)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).F0)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf81)))
		utf82 := unsafe.Pointer(unsafe.StringData((element).F1))
		pinner.Pin(utf82)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).F1)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf82)))

	}

	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (6 * 4))) = uint32(length)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (5 * 4))) = uint32(uintptr(uintptr(result3)))
	utf84 := unsafe.Pointer(unsafe.StringData((span).ParentSpanId))
	pinner.Pin(utf84)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (8 * 4))) = uint32(uint32(len((span).ParentSpanId)))
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (7 * 4))) = uint32(uintptr(uintptr(utf84)))
	*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (9 * 4))) = int8(int32((span).SpanKind))
	utf85 := unsafe.Pointer(unsafe.StringData((span).Name))
	pinner.Pin(utf85)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (11 * 4))) = uint32(uint32(len((span).Name)))
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (10 * 4))) = uint32(uintptr(uintptr(utf85)))
	*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), (12 * 4))) = int64(((span).StartTime).Seconds)
	*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (8 + 12*4))) = int32(((span).StartTime).Nanoseconds)
	*(*int64)(unsafe.Add(unsafe.Pointer(returnArea), (16 + 12*4))) = int64(((span).EndTime).Seconds)
	*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (24 + 12*4))) = int32(((span).EndTime).Nanoseconds)
	slice8 := (span).Attributes
	length10 := uint32(len(slice8))
	result9 := wit_runtime.Allocate(pinner, uintptr(length10*(4*4)), 4)
	for index, element := range slice8 {
		base := unsafe.Add(result9, index*(4*4))
		utf86 := unsafe.Pointer(unsafe.StringData((element).Key))
		pinner.Pin(utf86)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf86)))
		utf87 := unsafe.Pointer(unsafe.StringData((element).Value))
		pinner.Pin(utf87)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf87)))

	}

	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 13*4))) = uint32(length10)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 12*4))) = uint32(uintptr(uintptr(result9)))
	slice17 := (span).Events
	length19 := uint32(len(slice17))
	result18 := wit_runtime.Allocate(pinner, uintptr(length19*(16+4*4)), 8)
	for index, element := range slice17 {
		base := unsafe.Add(result18, index*(16+4*4))
		utf811 := unsafe.Pointer(unsafe.StringData((element).Name))
		pinner.Pin(utf811)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Name)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf811)))
		*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
		*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)
		slice14 := (element).Attributes
		length16 := uint32(len(slice14))
		result15 := wit_runtime.Allocate(pinner, uintptr(length16*(4*4)), 4)
		for index, element := range slice14 {
			base := unsafe.Add(result15, index*(4*4))
			utf812 := unsafe.Pointer(unsafe.StringData((element).Key))
			pinner.Pin(utf812)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf812)))
			utf813 := unsafe.Pointer(unsafe.StringData((element).Value))
			pinner.Pin(utf813)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf813)))

		}

		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length16)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result15)))

	}

	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 15*4))) = uint32(length19)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 14*4))) = uint32(uintptr(uintptr(result18)))
	slice33 := (span).Links
	length35 := uint32(len(slice33))
	result34 := wit_runtime.Allocate(pinner, uintptr(length35*(9*4)), 4)
	for index, element := range slice33 {
		base := unsafe.Add(result34, index*(9*4))
		utf820 := unsafe.Pointer(unsafe.StringData(((element).SpanContext).TraceId))
		pinner.Pin(utf820)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len(((element).SpanContext).TraceId)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf820)))
		utf821 := unsafe.Pointer(unsafe.StringData(((element).SpanContext).SpanId))
		pinner.Pin(utf821)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len(((element).SpanContext).SpanId)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf821)))
		*(*int8)(unsafe.Add(unsafe.Pointer(base), (4 * 4))) = int8(int32(((element).SpanContext).TraceFlags))
		var result22 int32
		if ((element).SpanContext).IsRemote {
			result22 = 1
		} else {
			result22 = 0
		}
		*(*int8)(unsafe.Add(unsafe.Pointer(base), (1 + 4*4))) = int8(result22)
		slice25 := ((element).SpanContext).TraceState
		length27 := uint32(len(slice25))
		result26 := wit_runtime.Allocate(pinner, uintptr(length27*(4*4)), 4)
		for index, element := range slice25 {
			base := unsafe.Add(result26, index*(4*4))
			utf823 := unsafe.Pointer(unsafe.StringData((element).F0))
			pinner.Pin(utf823)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).F0)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf823)))
			utf824 := unsafe.Pointer(unsafe.StringData((element).F1))
			pinner.Pin(utf824)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).F1)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf824)))

		}

		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = uint32(length27)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (5 * 4))) = uint32(uintptr(uintptr(result26)))
		slice30 := (element).Attributes
		length32 := uint32(len(slice30))
		result31 := wit_runtime.Allocate(pinner, uintptr(length32*(4*4)), 4)
		for index, element := range slice30 {
			base := unsafe.Add(result31, index*(4*4))
			utf828 := unsafe.Pointer(unsafe.StringData((element).Key))
			pinner.Pin(utf828)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf828)))
			utf829 := unsafe.Pointer(unsafe.StringData((element).Value))
			pinner.Pin(utf829)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf829)))

		}

		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 * 4))) = uint32(length32)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (7 * 4))) = uint32(uintptr(uintptr(result31)))

	}

	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 17*4))) = uint32(length35)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 16*4))) = uint32(uintptr(uintptr(result34)))

	switch (span).Status.Tag() {
	case StatusUnset:

		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 18*4))) = int8(int32(0))

	case StatusOk:

		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 18*4))) = int8(int32(1))

	case StatusError:
		payload := (span).Status.Error()
		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 18*4))) = int8(int32(2))
		utf836 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf836)
		*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 20*4))) = uint32(uint32(len(payload)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 19*4))) = uint32(uintptr(uintptr(utf836)))

	default:
		panic("unreachable")
	}
	utf837 := unsafe.Pointer(unsafe.StringData(((span).InstrumentationScope).Name))
	pinner.Pin(utf837)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 22*4))) = uint32(uint32(len(((span).InstrumentationScope).Name)))
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 21*4))) = uint32(uintptr(uintptr(utf837)))

	switch ((span).InstrumentationScope).Version.Tag() {
	case wit_types.OptionNone:
		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 23*4))) = int8(int32(0))

	case wit_types.OptionSome:
		payload := ((span).InstrumentationScope).Version.Some()
		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 23*4))) = int8(int32(1))
		utf838 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf838)
		*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 25*4))) = uint32(uint32(len(payload)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 24*4))) = uint32(uintptr(uintptr(utf838)))

	default:
		panic("unreachable")
	}

	switch ((span).InstrumentationScope).SchemaUrl.Tag() {
	case wit_types.OptionNone:
		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 26*4))) = int8(int32(0))

	case wit_types.OptionSome:
		payload := ((span).InstrumentationScope).SchemaUrl.Some()
		*(*int8)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 26*4))) = int8(int32(1))
		utf839 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf839)
		*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 28*4))) = uint32(uint32(len(payload)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 27*4))) = uint32(uintptr(uintptr(utf839)))

	default:
		panic("unreachable")
	}
	slice42 := ((span).InstrumentationScope).Attributes
	length44 := uint32(len(slice42))
	result43 := wit_runtime.Allocate(pinner, uintptr(length44*(4*4)), 4)
	for index, element := range slice42 {
		base := unsafe.Add(result43, index*(4*4))
		utf840 := unsafe.Pointer(unsafe.StringData((element).Key))
		pinner.Pin(utf840)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf840)))
		utf841 := unsafe.Pointer(unsafe.StringData((element).Value))
		pinner.Pin(utf841)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf841)))

	}

	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 30*4))) = uint32(length44)
	*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 29*4))) = uint32(uintptr(uintptr(result43)))
	*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (32 + 31*4))) = int32((span).DroppedAttributes)
	*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (36 + 31*4))) = int32((span).DroppedEvents)
	*(*int32)(unsafe.Add(unsafe.Pointer(returnArea), (40 + 31*4))) = int32((span).DroppedLinks)
	wasm_import_on_end(returnArea)

}

//go:wasmimport wasi:otel/tracing@0.2.0-draft outer-span-context
func wasm_import_outer_span_context(arg0 uintptr)

func OuterSpanContext() SpanContext {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (7 * 4), 4))
	wasm_import_outer_span_context(returnArea)
	value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4)))
	value0 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (3 * 4))))
	result := make([]wit_types.Tuple2[string, string], 0, *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (6 * 4))))
	for index := 0; index < int(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (6 * 4)))); index++ {
		base := unsafe.Add(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (5 * 4))))), index*(4*4))
		value1 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0))))), *(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)))
		value2 := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4)))))), *(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))))

		result = append(result, wit_types.Tuple2[string, string]{value1, value2})
	}

	result3 := SpanContext{value, value0, uint8(uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (4 * 4))))), (uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (1 + 4*4)))) != 0), result}
	return result3

}
