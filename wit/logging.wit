// // Modeled after the LogExporter: https://github.com/open-telemetry/opentelemetry-rust/blob/5c1c6da6ac76edca3cae59f3f52e57ab1534f1a6/opentelemetry-sdk/src/logs/export.rs#L116
// interface logging {
//     use wasi:clocks/wall-clock@0.2.0.{datetime};
//     use wasi:clocks/monotonic-clock@0.2.0.{duration};

//     %export: func(batch: log-batch) -> result<_, otel-sdk-error>;

//     shutdown-with-timeout: func(timeout: duration) -> result<_, otel-sdk-error>;
//     shutdown: func() -> result<_, otel-sdk-error>; // Calls `shutdown-with-timeout` with a 5 second duration
//     // TODO: it looks like the `event_enabled` function might not be stable? See https://github.com/open-telemetry/opentelemetry-rust/blob/5c1c6da6ac76edca3cae59f3f52e57ab1534f1a6/opentelemetry-sdk/src/logs/export.rs#L148
//     set-resource: func(%resource: %resource);

//     variant otel-sdk-error {
//         internal-failure(string),
//         timeout(duration),
//         already-shutdown,
//     }

//     record log-batch {
//         // TODO: unclear whether this is correct, since the rust implementation seems to have differentiations between owned and borrowed data: https://github.com/open-telemetry/opentelemetry-rust/blob/5c1c6da6ac76edca3cae59f3f52e57ab1534f1a6/opentelemetry-sdk/src/logs/export.rs#L30
//         data: tuple<sdk-log-record, instrumentation-scope>,
//     }

//     record sdk-log-record {
//         event-name: option<string>,
//         target: option<string>,
//         timestamp: option<datetime>,
//         observed-timestamp: option<datetime>,
//         trace-context: option<trace-context>,
//         severity-text: option<string>,
//         severity-number: option<severity>,
//         body: option<any-value>,
//         // TODO: Check that this matches LogRecordAttributes: https://github.com/open-telemetry/opentelemetry-rust/blob/5c1c6da6ac76edca3cae59f3f52e57ab1534f1a6/opentelemetry-sdk/src/logs/record.rs#L18
//         attributes: list<option<tuple<key, any-value>>>,
//     }

//     record trace-context {
//         trace-id: trace-id,
//         span-id: span-id,
//         trace-flags: option<trace-flags>,
//     }

//      /// The trace that this `span-context` belongs to.
//     ///
//     /// 16 bytes encoded as a hexadecimal string.
//     type trace-id = string;

//     /// The id of this `span-context`.
//     ///
//     /// 8 bytes encoded as a hexadecimal string.
//     type span-id = string;

//     /// Flags that can be set on a `span-context`.
//     flags trace-flags {
//         /// Whether the `span` should be sampled or not.
//         sampled,
//     }

//     enum severity {
//         /// Trace = 1
//         trace,
//         /// Trace2 = 2
//         trace2,
//         /// Trace3 = 3
//         trace3,
//         /// Trace4 = 4
//         trace4,
//         /// Debug = 5
//         debug,
//         /// Debug2 = 6
//         debug2,
//         /// Debug3 = 7
//         debug3,
//         /// Debug4 = 8
//         debug4,
//         /// Info = 9
//         info,
//         /// Info2 = 10
//         info2,
//         /// Info3 = 11
//         info3,
//         /// Info4 = 12
//         info4,
//         /// Warn = 13
//         warn,
//         /// Warn2 = 14
//         warn2,
//         /// Warn3 = 15
//         warn3,
//         /// Warn4 = 16
//         warn4,
//         /// Error = 17
//         error,
//         /// Error2 = 18
//         error2,
//         /// Error3 = 19
//         error3,
//         /// Error4 = 20
//         error4,
//         /// Fatal = 21
//         fatal,
//         /// Fatal2 = 22
//         fatal2,
//         /// Fatal3 = 23
//         fatal3,
//         /// Fatal4 = 24
//         fatal4,
//     }

//     variant any-value {
//         string-value(string),
//         bool-value(bool),
//         int-value(s64),
//         double-value(f64),
//         array-value(list<any-value>), // TODO: figure out how to implement this https://github.com/open-telemetry/opentelemetry-rust/blob/5c1c6da6ac76edca3cae59f3f52e57ab1534f1a6/opentelemetry-proto/src/proto/tonic/opentelemetry.proto.common.v1.rs#L24
//         kv-list-value(list<key-value>),
//         bytes-value(list<u8>),
//     }

//     record instrumentation-scope {
//         name: string,
//         version: option<string>,
//         schema-url: option<string>,
//         attributes: list<key-value>,
//     }

//     record %resource {
//         inner: resource-inner,
//     }

//     /// A key-value pair describing an attribute.
//     record key-value {
//         /// The attribute name.
//         key: key,
//         /// The attribute value.
//         value: value,
//     }

//     /// The key part of attribute `key-value` pairs.
//     type key = string;

//     /// The value part of attribute `key-value` pairs.
//     variant value {
//         /// A string value.
//         %string(string),
//         /// A boolean value.
//         %bool(bool),
//         /// A double precision floating point value.
//         %f64(f64),
//         /// A signed 64 bit integer value.
//         %s64(s64),
//         /// A homogeneous array of string values.
//         string-array(list<string>),
//         /// A homogeneous array of boolean values.
//         bool-array(list<bool>),
//         /// A homogeneous array of double precision floating point values.
//         f64-array(list<f64>),
//         /// A homogeneous array of 64 bit integer values.
//         s64-array(list<s64>),
//     }

//     record resource-inner {
//         // TODO: not sure if this is the best way to handle this? The type listed in the `opentelemetry-sdk/resource/mod.rs` file is `HashMap<Key, Value>`
//         // https://github.com/open-telemetry/opentelemetry-rust/blob/189078d7a92e534d67137ffaed8e35456eaa589b/opentelemetry-sdk/src/resource/mod.rs#L43
//         attrs: list<key-value>,
//         schema-url: option<string>,
//     }
// }