// Generated by `wit-bindgen` 0.51.0. DO NOT EDIT!
//
// This code was generated from the following packages:
//     wasi:io@0.2.0
//     wasi:clocks@0.2.0
//     wasi:otel@0.2.0-rc.2

package wasi_otel_metrics

import (
	"github.com/bytecodealliance/wit-bindgen/wit_runtime"
	"github.com/bytecodealliance/wit-bindgen/wit_types"
	"github.com/calebschoepp/opentelemetry-wasi/internal/wasi_clocks_wall_clock"
	"github.com/calebschoepp/opentelemetry-wasi/internal/wasi_otel_types"
	"runtime"
	"unsafe"
)

type Datetime = wasi_clocks_wall_clock.Datetime
type Duration = uint64
type KeyValue = wasi_otel_types.KeyValue
type InstrumentationScope = wasi_otel_types.InstrumentationScope
type Resource = wasi_otel_types.Resource
type SpanId = string
type TraceId = string

// An error resulting from `export` being called.
type Error = string

// A set of bucket counts, encoded in a contiguous array of counts.
type ExponentialBucket struct {
	// The bucket index of the first entry in the `counts` list.
	Offset int32
	// A list where `counts[i]` carries the count of the bucket at index `offset + i`.
	//
	// `counts[i]` is the count of values greater than base^(offset+i) and less than
	// or equal to base^(offset+i+1).
	Counts []uint64
}

const (
	// A measurement interval that continues to expand forward in time from a
	// starting point.
	//
	// New measurements are added to all previous measurements since a start time.
	//
	// This is the default temporality.
	TemporalityCumulative uint8 = 0
	// A measurement interval that resets each cycle.
	//
	// Measurements from one cycle are recorded independently, measurements from
	// other cycles do not affect them.
	TemporalityDelta uint8 = 1
	// Configures Synchronous Counter and Histogram instruments to use
	// Delta aggregation temporality, which allows them to shed memory
	// following a cardinality explosion, thus use less memory.
	TemporalityLowMemory uint8 = 2
)

// Defines the window that an aggregation was calculated over.
type Temporality = uint8

const (
	MetricNumberF64 uint8 = 0
	MetricNumberS64 uint8 = 1
	MetricNumberU64 uint8 = 2
)

// The number types available for any given instrument.
type MetricNumber struct {
	tag   uint8
	value any
}

func (self MetricNumber) Tag() uint8 {
	return self.tag
}

func (self MetricNumber) F64() float64 {
	if self.tag != MetricNumberF64 {
		panic("tag mismatch")
	}
	return self.value.(float64)
}
func (self MetricNumber) S64() int64 {
	if self.tag != MetricNumberS64 {
		panic("tag mismatch")
	}
	return self.value.(int64)
}
func (self MetricNumber) U64() uint64 {
	if self.tag != MetricNumberU64 {
		panic("tag mismatch")
	}
	return self.value.(uint64)
}

func MakeMetricNumberF64(value float64) MetricNumber {
	return MetricNumber{MetricNumberF64, value}
}
func MakeMetricNumberS64(value int64) MetricNumber {
	return MetricNumber{MetricNumberS64, value}
}
func MakeMetricNumberU64(value uint64) MetricNumber {
	return MetricNumber{MetricNumberU64, value}
}

// A measurement sampled from a time series providing a typical example.
type Exemplar struct {
	// The attributes recorded with the measurement but filtered out of the
	// time series' aggregated data.
	FilteredAttributes []wasi_otel_types.KeyValue
	// The time when the measurement was recorded.
	Time wasi_clocks_wall_clock.Datetime
	// The measured value.
	Value MetricNumber
	// The ID of the span that was active during the measurement.
	//
	// If no span was active or the span was not sampled this will be empty.
	SpanId string
	// The ID of the trace the active span belonged to during the measurement.
	//
	// If no span was active or the span was not sampled this will be empty.
	TraceId string
}

// A single data point in a time series to be associated with a `gauge`.
type GaugeDataPoint struct {
	// `attributes` is the set of key value pairs that uniquely identify the
	// time series.
	Attributes []wasi_otel_types.KeyValue
	// The value of this data point.
	Value MetricNumber
	// The sampled `exemplar`s collected during the time series.
	Exemplars []Exemplar
}

// A measurement of the current value of an instrument.
type Gauge struct {
	// Represents individual aggregated measurements with unique attributes.
	DataPoints []GaugeDataPoint
	// The time when the time series was started.
	StartTime wit_types.Option[wasi_clocks_wall_clock.Datetime]
	// The time when the time series was recorded.
	Time wasi_clocks_wall_clock.Datetime
}

// A single data point in a time series to be associated with a `sum`.
type SumDataPoint struct {
	// `attributes` is the set of key value pairs that uniquely identify the
	// time series.
	Attributes []wasi_otel_types.KeyValue
	// The value of this data point.
	Value MetricNumber
	// The sampled `exemplar`s collected during the time series.
	Exemplars []Exemplar
}

// Represents the sum of all measurements of values from an instrument.
type Sum struct {
	// Represents individual aggregated measurements with unique attributes.
	DataPoints []SumDataPoint
	// The time when the time series was started.
	StartTime wasi_clocks_wall_clock.Datetime
	// The time when the time series was recorded.
	Time wasi_clocks_wall_clock.Datetime
	// Describes if the aggregation is reported as the change from the last report
	// time, or the cumulative changes since a fixed start time.
	Temporality Temporality
	// Whether this aggregation only increases or decreases.
	IsMonotonic bool
}

// A single data point in a time series to be associated with a `histogram`.
type HistogramDataPoint struct {
	// The set of key value pairs that uniquely identify the time series.
	Attributes []wasi_otel_types.KeyValue
	// The number of updates this histogram has been calculated with.
	Count uint64
	// The upper bounds of the buckets of the histogram.
	Bounds []float64
	// The count of each of the buckets.
	BucketCounts []uint64
	// The minimum value recorded.
	Min wit_types.Option[MetricNumber]
	// The maximum value recorded.
	Max wit_types.Option[MetricNumber]
	// The sum of the values recorded
	Sum MetricNumber
	// The sampled `exemplar`s collected during the time series.
	Exemplars []Exemplar
}

// Represents the histogram of all measurements of values from an instrument.
type Histogram struct {
	// Individual aggregated measurements with unique attributes.
	DataPoints []HistogramDataPoint
	// The time when the time series was started.
	StartTime wasi_clocks_wall_clock.Datetime
	// The time when the time series was recorded.
	Time wasi_clocks_wall_clock.Datetime
	// Describes if the aggregation is reported as the change from the last report
	// time, or the cumulative changes since a fixed start time.
	Temporality Temporality
}

// A single data point in a time series to be associated with an `exponential-histogram `.
type ExponentialHistogramDataPoint struct {
	// The set of key value pairs that uniquely identify the time series.
	Attributes []wasi_otel_types.KeyValue
	// The number of updates this histogram has been calculated with.
	Count uint64
	// The minimum value recorded.
	Min wit_types.Option[MetricNumber]
	// The maximum value recorded.
	Max wit_types.Option[MetricNumber]
	// The maximum value recorded.
	Sum MetricNumber
	// Describes the resolution of the histogram.
	//
	// Boundaries are located at powers of the base, where:
	//
	//	base = 2 ^ (2 ^ -scale)
	Scale int8
	// The number of values whose absolute value is less than or equal to
	// `zero_threshold`.
	//
	// When `zero_threshold` is `0`, this is the number of values that cannot be
	// expressed using the standard exponential formula as well as values that have
	// been rounded to zero.
	ZeroCount uint64
	// The range of positive value bucket counts.
	PositiveBucket ExponentialBucket
	// The range of negative value bucket counts.
	NegativeBucket ExponentialBucket
	// The width of the zero region.
	//
	// Where the zero region is defined as the closed interval
	// [-zero_threshold, zero_threshold].
	ZeroThreshold float64
	// The sampled exemplars collected during the time series.
	Exemplars []Exemplar
}

// The histogram of all measurements of values from an instrument.
type ExponentialHistogram struct {
	// The individual aggregated measurements with unique attributes.
	DataPoints []ExponentialHistogramDataPoint
	// When the time series was started.
	StartTime wasi_clocks_wall_clock.Datetime
	// The time when the time series was recorded.
	Time wasi_clocks_wall_clock.Datetime
	// Describes if the aggregation is reported as the change from the last report
	// time, or the cumulative changes since a fixed start time.
	Temporality Temporality
}

const (
	// Metric data for an f64 gauge.
	MetricDataF64Gauge uint8 = 0
	// Metric data for an f64 sum.
	MetricDataF64Sum uint8 = 1
	// Metric data for an f64 histogram.
	MetricDataF64Histogram uint8 = 2
	// Metric data for an f64 exponential-histogram.
	MetricDataF64ExponentialHistogram uint8 = 3
	// Metric data for an u64 gauge.
	MetricDataU64Gauge uint8 = 4
	// Metric data for an u64 sum.
	MetricDataU64Sum uint8 = 5
	// Metric data for an u64 histogram.
	MetricDataU64Histogram uint8 = 6
	// Metric data for an u64 exponential-histogram.
	MetricDataU64ExponentialHistogram uint8 = 7
	// Metric data for an s64 gauge.
	MetricDataS64Gauge uint8 = 8
	// Metric data for an s64 sum.
	MetricDataS64Sum uint8 = 9
	// Metric data for an s64 histogram.
	MetricDataS64Histogram uint8 = 10
	// Metric data for an s64 exponential-histogram.
	MetricDataS64ExponentialHistogram uint8 = 11
)

// Metric data for all types.
type MetricData struct {
	tag   uint8
	value any
}

func (self MetricData) Tag() uint8 {
	return self.tag
}

func (self MetricData) F64Gauge() Gauge {
	if self.tag != MetricDataF64Gauge {
		panic("tag mismatch")
	}
	return self.value.(Gauge)
}
func (self MetricData) F64Sum() Sum {
	if self.tag != MetricDataF64Sum {
		panic("tag mismatch")
	}
	return self.value.(Sum)
}
func (self MetricData) F64Histogram() Histogram {
	if self.tag != MetricDataF64Histogram {
		panic("tag mismatch")
	}
	return self.value.(Histogram)
}
func (self MetricData) F64ExponentialHistogram() ExponentialHistogram {
	if self.tag != MetricDataF64ExponentialHistogram {
		panic("tag mismatch")
	}
	return self.value.(ExponentialHistogram)
}
func (self MetricData) U64Gauge() Gauge {
	if self.tag != MetricDataU64Gauge {
		panic("tag mismatch")
	}
	return self.value.(Gauge)
}
func (self MetricData) U64Sum() Sum {
	if self.tag != MetricDataU64Sum {
		panic("tag mismatch")
	}
	return self.value.(Sum)
}
func (self MetricData) U64Histogram() Histogram {
	if self.tag != MetricDataU64Histogram {
		panic("tag mismatch")
	}
	return self.value.(Histogram)
}
func (self MetricData) U64ExponentialHistogram() ExponentialHistogram {
	if self.tag != MetricDataU64ExponentialHistogram {
		panic("tag mismatch")
	}
	return self.value.(ExponentialHistogram)
}
func (self MetricData) S64Gauge() Gauge {
	if self.tag != MetricDataS64Gauge {
		panic("tag mismatch")
	}
	return self.value.(Gauge)
}
func (self MetricData) S64Sum() Sum {
	if self.tag != MetricDataS64Sum {
		panic("tag mismatch")
	}
	return self.value.(Sum)
}
func (self MetricData) S64Histogram() Histogram {
	if self.tag != MetricDataS64Histogram {
		panic("tag mismatch")
	}
	return self.value.(Histogram)
}
func (self MetricData) S64ExponentialHistogram() ExponentialHistogram {
	if self.tag != MetricDataS64ExponentialHistogram {
		panic("tag mismatch")
	}
	return self.value.(ExponentialHistogram)
}

func MakeMetricDataF64Gauge(value Gauge) MetricData {
	return MetricData{MetricDataF64Gauge, value}
}
func MakeMetricDataF64Sum(value Sum) MetricData {
	return MetricData{MetricDataF64Sum, value}
}
func MakeMetricDataF64Histogram(value Histogram) MetricData {
	return MetricData{MetricDataF64Histogram, value}
}
func MakeMetricDataF64ExponentialHistogram(value ExponentialHistogram) MetricData {
	return MetricData{MetricDataF64ExponentialHistogram, value}
}
func MakeMetricDataU64Gauge(value Gauge) MetricData {
	return MetricData{MetricDataU64Gauge, value}
}
func MakeMetricDataU64Sum(value Sum) MetricData {
	return MetricData{MetricDataU64Sum, value}
}
func MakeMetricDataU64Histogram(value Histogram) MetricData {
	return MetricData{MetricDataU64Histogram, value}
}
func MakeMetricDataU64ExponentialHistogram(value ExponentialHistogram) MetricData {
	return MetricData{MetricDataU64ExponentialHistogram, value}
}
func MakeMetricDataS64Gauge(value Gauge) MetricData {
	return MetricData{MetricDataS64Gauge, value}
}
func MakeMetricDataS64Sum(value Sum) MetricData {
	return MetricData{MetricDataS64Sum, value}
}
func MakeMetricDataS64Histogram(value Histogram) MetricData {
	return MetricData{MetricDataS64Histogram, value}
}
func MakeMetricDataS64ExponentialHistogram(value ExponentialHistogram) MetricData {
	return MetricData{MetricDataS64ExponentialHistogram, value}
}

// A collection of one or more aggregated time series from a metric.
type Metric struct {
	// The name of the metric that created this data.
	Name string
	// The description of the metric, which can be used in documentation.
	Description string
	// The unit in which the metric reports.
	Unit string
	// The aggregated data from a metric.
	Data MetricData
}

// A collection of `metric`s produced by a meter.
type ScopeMetrics struct {
	// The instrumentation scope that the meter was created with.
	Scope wasi_otel_types.InstrumentationScope
	// The list of aggregations created by the meter.
	Metrics []Metric
}

// A collection of `scope-metrics` and the associated `resource` that created them.
type ResourceMetrics struct {
	// The entity that collected the metrics.
	Resource wasi_otel_types.Resource
	// The collection of metrics with unique `instrumentation-scope`s.
	ScopeMetrics []ScopeMetrics
}

//go:wasmimport wasi:otel/metrics@0.2.0-rc.2 export
func wasm_import_export(arg0 uintptr, arg1 uint32, arg2 int32, arg3 uintptr, arg4 uint32, arg5 uintptr, arg6 uint32, arg7 uintptr)

func Export(metrics ResourceMetrics) wit_types.Result[wit_types.Unit, string] {
	pinner := &runtime.Pinner{}
	defer pinner.Unpin()

	returnArea := uintptr(wit_runtime.Allocate(pinner, (3 * 4), 4))
	slice := ((metrics).Resource).Attributes
	length := uint32(len(slice))
	result := wit_runtime.Allocate(pinner, uintptr(length*(4*4)), 4)
	for index, element := range slice {
		base := unsafe.Add(result, index*(4*4))
		utf8 := unsafe.Pointer(unsafe.StringData((element).Key))
		pinner.Pin(utf8)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8)))
		utf80 := unsafe.Pointer(unsafe.StringData((element).Value))
		pinner.Pin(utf80)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf80)))

	}

	var option int32
	var option2 uintptr
	var option3 uint32
	switch ((metrics).Resource).SchemaUrl.Tag() {
	case wit_types.OptionNone:

		option = int32(0)
		option2 = 0
		option3 = 0
	case wit_types.OptionSome:
		payload := ((metrics).Resource).SchemaUrl.Some()
		utf81 := unsafe.Pointer(unsafe.StringData(payload))
		pinner.Pin(utf81)

		option = int32(1)
		option2 = uintptr(utf81)
		option3 = uint32(len(payload))
	default:
		panic("unreachable")
	}
	slice248 := (metrics).ScopeMetrics
	length250 := uint32(len(slice248))
	result249 := wit_runtime.Allocate(pinner, uintptr(length250*(12*4)), 4)
	for index, element := range slice248 {
		base := unsafe.Add(result249, index*(12*4))
		utf84 := unsafe.Pointer(unsafe.StringData(((element).Scope).Name))
		pinner.Pin(utf84)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len(((element).Scope).Name)))
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf84)))

		switch ((element).Scope).Version.Tag() {
		case wit_types.OptionNone:
			*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))

		case wit_types.OptionSome:
			payload := ((element).Scope).Version.Some()
			*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
			utf85 := unsafe.Pointer(unsafe.StringData(payload))
			pinner.Pin(utf85)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (4 * 4))) = uint32(uint32(len(payload)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uintptr(uintptr(utf85)))

		default:
			panic("unreachable")
		}

		switch ((element).Scope).SchemaUrl.Tag() {
		case wit_types.OptionNone:
			*(*int8)(unsafe.Add(unsafe.Pointer(base), (5 * 4))) = int8(int32(0))

		case wit_types.OptionSome:
			payload := ((element).Scope).SchemaUrl.Some()
			*(*int8)(unsafe.Add(unsafe.Pointer(base), (5 * 4))) = int8(int32(1))
			utf86 := unsafe.Pointer(unsafe.StringData(payload))
			pinner.Pin(utf86)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (7 * 4))) = uint32(uint32(len(payload)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = uint32(uintptr(uintptr(utf86)))

		default:
			panic("unreachable")
		}
		slice9 := ((element).Scope).Attributes
		length11 := uint32(len(slice9))
		result10 := wit_runtime.Allocate(pinner, uintptr(length11*(4*4)), 4)
		for index, element := range slice9 {
			base := unsafe.Add(result10, index*(4*4))
			utf87 := unsafe.Pointer(unsafe.StringData((element).Key))
			pinner.Pin(utf87)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf87)))
			utf88 := unsafe.Pointer(unsafe.StringData((element).Value))
			pinner.Pin(utf88)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf88)))

		}

		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (9 * 4))) = uint32(length11)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 * 4))) = uint32(uintptr(uintptr(result10)))
		slice245 := (element).Metrics
		length247 := uint32(len(slice245))
		result246 := wit_runtime.Allocate(pinner, uintptr(length247*(48+8*4)), 8)
		for index, element := range slice245 {
			base := unsafe.Add(result246, index*(48+8*4))
			utf812 := unsafe.Pointer(unsafe.StringData((element).Name))
			pinner.Pin(utf812)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Name)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf812)))
			utf813 := unsafe.Pointer(unsafe.StringData((element).Description))
			pinner.Pin(utf813)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Description)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf813)))
			utf814 := unsafe.Pointer(unsafe.StringData((element).Unit))
			pinner.Pin(utf814)
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (5 * 4))) = uint32(uint32(len((element).Unit)))
			*(*uint32)(unsafe.Add(unsafe.Pointer(base), (4 * 4))) = uint32(uintptr(uintptr(utf814)))

			switch (element).Data.Tag() {
			case MetricDataF64Gauge:
				payload := (element).Data.F64Gauge()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(0))
				slice30 := (payload).DataPoints
				length32 := uint32(len(slice30))
				result31 := wit_runtime.Allocate(pinner, uintptr(length32*(16+4*4)), 8)
				for index, element := range slice30 {
					base := unsafe.Add(result31, index*(16+4*4))
					slice17 := (element).Attributes
					length19 := uint32(len(slice17))
					result18 := wit_runtime.Allocate(pinner, uintptr(length19*(4*4)), 4)
					for index, element := range slice17 {
						base := unsafe.Add(result18, index*(4*4))
						utf815 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf815)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf815)))
						utf816 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf816)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf816)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length19)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result18)))

					switch (element).Value.Tag() {
					case MetricNumberF64:
						payload := (element).Value.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Value.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Value.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice27 := (element).Exemplars
					length29 := uint32(len(slice27))
					result28 := wit_runtime.Allocate(pinner, uintptr(length29*(32+6*4)), 8)
					for index, element := range slice27 {
						base := unsafe.Add(result28, index*(32+6*4))
						slice22 := (element).FilteredAttributes
						length24 := uint32(len(slice22))
						result23 := wit_runtime.Allocate(pinner, uintptr(length24*(4*4)), 4)
						for index, element := range slice22 {
							base := unsafe.Add(result23, index*(4*4))
							utf820 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf820)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf820)))
							utf821 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf821)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf821)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length24)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result23)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf825 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf825)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf825)))
						utf826 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf826)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf826)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length29)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result28)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length32)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result31)))

				switch (payload).StartTime.Tag() {
				case wit_types.OptionNone:
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int8(int32(0))

				case wit_types.OptionSome:
					payload := (payload).StartTime.Some()
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int8(int32(1))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int64((payload).Seconds)
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int32((payload).Nanoseconds)

				default:
					panic("unreachable")
				}
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int32(((payload).Time).Nanoseconds)

			case MetricDataF64Sum:
				payload := (element).Data.F64Sum()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(1))
				slice48 := (payload).DataPoints
				length50 := uint32(len(slice48))
				result49 := wit_runtime.Allocate(pinner, uintptr(length50*(16+4*4)), 8)
				for index, element := range slice48 {
					base := unsafe.Add(result49, index*(16+4*4))
					slice35 := (element).Attributes
					length37 := uint32(len(slice35))
					result36 := wit_runtime.Allocate(pinner, uintptr(length37*(4*4)), 4)
					for index, element := range slice35 {
						base := unsafe.Add(result36, index*(4*4))
						utf833 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf833)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf833)))
						utf834 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf834)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf834)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length37)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result36)))

					switch (element).Value.Tag() {
					case MetricNumberF64:
						payload := (element).Value.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Value.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Value.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice45 := (element).Exemplars
					length47 := uint32(len(slice45))
					result46 := wit_runtime.Allocate(pinner, uintptr(length47*(32+6*4)), 8)
					for index, element := range slice45 {
						base := unsafe.Add(result46, index*(32+6*4))
						slice40 := (element).FilteredAttributes
						length42 := uint32(len(slice40))
						result41 := wit_runtime.Allocate(pinner, uintptr(length42*(4*4)), 4)
						for index, element := range slice40 {
							base := unsafe.Add(result41, index*(4*4))
							utf838 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf838)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf838)))
							utf839 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf839)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf839)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length42)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result41)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf843 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf843)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf843)))
						utf844 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf844)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf844)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length47)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result46)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length50)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result49)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))
				var result51 int32
				if (payload).IsMonotonic {
					result51 = 1
				} else {
					result51 = 0
				}
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (41 + 8*4))) = int8(result51)

			case MetricDataF64Histogram:
				payload := (element).Data.F64Histogram()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(2))
				slice68 := (payload).DataPoints
				length70 := uint32(len(slice68))
				result69 := wit_runtime.Allocate(pinner, uintptr(length70*(72+8*4)), 8)
				for index, element := range slice68 {
					base := unsafe.Add(result69, index*(72+8*4))
					slice54 := (element).Attributes
					length56 := uint32(len(slice54))
					result55 := wit_runtime.Allocate(pinner, uintptr(length56*(4*4)), 4)
					for index, element := range slice54 {
						base := unsafe.Add(result55, index*(4*4))
						utf852 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf852)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf852)))
						utf853 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf853)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf853)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length56)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result55)))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64((element).Count)
					data := unsafe.Pointer(unsafe.SliceData((element).Bounds))
					pinner.Pin(data)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 3*4))) = uint32(uint32(len((element).Bounds)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = uint32(uintptr(uintptr(data)))
					data57 := unsafe.Pointer(unsafe.SliceData((element).BucketCounts))
					pinner.Pin(data57)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 5*4))) = uint32(uint32(len((element).BucketCounts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 4*4))) = uint32(uintptr(uintptr(data57)))

					switch (element).Min.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Min.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Max.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 6*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Max.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 6*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Sum.Tag() {
					case MetricNumberF64:
						payload := (element).Sum.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = payload

					case MetricNumberS64:
						payload := (element).Sum.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = payload

					case MetricNumberU64:
						payload := (element).Sum.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice65 := (element).Exemplars
					length67 := uint32(len(slice65))
					result66 := wit_runtime.Allocate(pinner, uintptr(length67*(32+6*4)), 8)
					for index, element := range slice65 {
						base := unsafe.Add(result66, index*(32+6*4))
						slice60 := (element).FilteredAttributes
						length62 := uint32(len(slice60))
						result61 := wit_runtime.Allocate(pinner, uintptr(length62*(4*4)), 4)
						for index, element := range slice60 {
							base := unsafe.Add(result61, index*(4*4))
							utf858 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf858)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf858)))
							utf859 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf859)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf859)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length62)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result61)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf863 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf863)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf863)))
						utf864 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf864)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf864)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (72 + 7*4))) = uint32(length67)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (72 + 6*4))) = uint32(uintptr(uintptr(result66)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length70)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result69)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))

			case MetricDataF64ExponentialHistogram:
				payload := (element).Data.F64ExponentialHistogram()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(3))
				slice88 := (payload).DataPoints
				length90 := uint32(len(slice88))
				result89 := wit_runtime.Allocate(pinner, uintptr(length90*(96+10*4)), 8)
				for index, element := range slice88 {
					base := unsafe.Add(result89, index*(96+10*4))
					slice73 := (element).Attributes
					length75 := uint32(len(slice73))
					result74 := wit_runtime.Allocate(pinner, uintptr(length75*(4*4)), 4)
					for index, element := range slice73 {
						base := unsafe.Add(result74, index*(4*4))
						utf871 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf871)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf871)))
						utf872 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf872)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf872)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length75)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result74)))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64((element).Count)

					switch (element).Min.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Min.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Max.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Max.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Sum.Tag() {
					case MetricNumberF64:
						payload := (element).Sum.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Sum.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Sum.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (72 + 2*4))) = int8(int32((element).Scale))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (80 + 2*4))) = int64((element).ZeroCount)
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (88 + 2*4))) = ((element).PositiveBucket).Offset
					data76 := unsafe.Pointer(unsafe.SliceData(((element).PositiveBucket).Counts))
					pinner.Pin(data76)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 4*4))) = uint32(uint32(len(((element).PositiveBucket).Counts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 3*4))) = uint32(uintptr(uintptr(data76)))
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (88 + 5*4))) = ((element).NegativeBucket).Offset
					data77 := unsafe.Pointer(unsafe.SliceData(((element).NegativeBucket).Counts))
					pinner.Pin(data77)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 7*4))) = uint32(uint32(len(((element).NegativeBucket).Counts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 6*4))) = uint32(uintptr(uintptr(data77)))
					*(*float64)(unsafe.Add(unsafe.Pointer(base), (88 + 8*4))) = (element).ZeroThreshold
					slice85 := (element).Exemplars
					length87 := uint32(len(slice85))
					result86 := wit_runtime.Allocate(pinner, uintptr(length87*(32+6*4)), 8)
					for index, element := range slice85 {
						base := unsafe.Add(result86, index*(32+6*4))
						slice80 := (element).FilteredAttributes
						length82 := uint32(len(slice80))
						result81 := wit_runtime.Allocate(pinner, uintptr(length82*(4*4)), 4)
						for index, element := range slice80 {
							base := unsafe.Add(result81, index*(4*4))
							utf878 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf878)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf878)))
							utf879 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf879)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf879)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length82)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result81)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf883 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf883)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf883)))
						utf884 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf884)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf884)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (96 + 9*4))) = uint32(length87)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (96 + 8*4))) = uint32(uintptr(uintptr(result86)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length90)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result89)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))

			case MetricDataU64Gauge:
				payload := (element).Data.U64Gauge()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(4))
				slice106 := (payload).DataPoints
				length108 := uint32(len(slice106))
				result107 := wit_runtime.Allocate(pinner, uintptr(length108*(16+4*4)), 8)
				for index, element := range slice106 {
					base := unsafe.Add(result107, index*(16+4*4))
					slice93 := (element).Attributes
					length95 := uint32(len(slice93))
					result94 := wit_runtime.Allocate(pinner, uintptr(length95*(4*4)), 4)
					for index, element := range slice93 {
						base := unsafe.Add(result94, index*(4*4))
						utf891 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf891)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf891)))
						utf892 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf892)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf892)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length95)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result94)))

					switch (element).Value.Tag() {
					case MetricNumberF64:
						payload := (element).Value.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Value.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Value.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice103 := (element).Exemplars
					length105 := uint32(len(slice103))
					result104 := wit_runtime.Allocate(pinner, uintptr(length105*(32+6*4)), 8)
					for index, element := range slice103 {
						base := unsafe.Add(result104, index*(32+6*4))
						slice98 := (element).FilteredAttributes
						length100 := uint32(len(slice98))
						result99 := wit_runtime.Allocate(pinner, uintptr(length100*(4*4)), 4)
						for index, element := range slice98 {
							base := unsafe.Add(result99, index*(4*4))
							utf896 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf896)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf896)))
							utf897 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf897)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf897)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length100)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result99)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8101 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8101)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8101)))
						utf8102 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8102)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8102)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length105)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result104)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length108)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result107)))

				switch (payload).StartTime.Tag() {
				case wit_types.OptionNone:
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int8(int32(0))

				case wit_types.OptionSome:
					payload := (payload).StartTime.Some()
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int8(int32(1))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int64((payload).Seconds)
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int32((payload).Nanoseconds)

				default:
					panic("unreachable")
				}
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int32(((payload).Time).Nanoseconds)

			case MetricDataU64Sum:
				payload := (element).Data.U64Sum()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(5))
				slice124 := (payload).DataPoints
				length126 := uint32(len(slice124))
				result125 := wit_runtime.Allocate(pinner, uintptr(length126*(16+4*4)), 8)
				for index, element := range slice124 {
					base := unsafe.Add(result125, index*(16+4*4))
					slice111 := (element).Attributes
					length113 := uint32(len(slice111))
					result112 := wit_runtime.Allocate(pinner, uintptr(length113*(4*4)), 4)
					for index, element := range slice111 {
						base := unsafe.Add(result112, index*(4*4))
						utf8109 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8109)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8109)))
						utf8110 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8110)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8110)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length113)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result112)))

					switch (element).Value.Tag() {
					case MetricNumberF64:
						payload := (element).Value.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Value.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Value.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice121 := (element).Exemplars
					length123 := uint32(len(slice121))
					result122 := wit_runtime.Allocate(pinner, uintptr(length123*(32+6*4)), 8)
					for index, element := range slice121 {
						base := unsafe.Add(result122, index*(32+6*4))
						slice116 := (element).FilteredAttributes
						length118 := uint32(len(slice116))
						result117 := wit_runtime.Allocate(pinner, uintptr(length118*(4*4)), 4)
						for index, element := range slice116 {
							base := unsafe.Add(result117, index*(4*4))
							utf8114 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8114)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8114)))
							utf8115 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8115)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8115)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length118)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result117)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8119 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8119)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8119)))
						utf8120 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8120)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8120)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length123)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result122)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length126)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result125)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))
				var result127 int32
				if (payload).IsMonotonic {
					result127 = 1
				} else {
					result127 = 0
				}
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (41 + 8*4))) = int8(result127)

			case MetricDataU64Histogram:
				payload := (element).Data.U64Histogram()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(6))
				slice145 := (payload).DataPoints
				length147 := uint32(len(slice145))
				result146 := wit_runtime.Allocate(pinner, uintptr(length147*(72+8*4)), 8)
				for index, element := range slice145 {
					base := unsafe.Add(result146, index*(72+8*4))
					slice130 := (element).Attributes
					length132 := uint32(len(slice130))
					result131 := wit_runtime.Allocate(pinner, uintptr(length132*(4*4)), 4)
					for index, element := range slice130 {
						base := unsafe.Add(result131, index*(4*4))
						utf8128 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8128)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8128)))
						utf8129 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8129)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8129)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length132)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result131)))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64((element).Count)
					data133 := unsafe.Pointer(unsafe.SliceData((element).Bounds))
					pinner.Pin(data133)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 3*4))) = uint32(uint32(len((element).Bounds)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = uint32(uintptr(uintptr(data133)))
					data134 := unsafe.Pointer(unsafe.SliceData((element).BucketCounts))
					pinner.Pin(data134)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 5*4))) = uint32(uint32(len((element).BucketCounts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 4*4))) = uint32(uintptr(uintptr(data134)))

					switch (element).Min.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Min.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Max.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 6*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Max.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 6*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Sum.Tag() {
					case MetricNumberF64:
						payload := (element).Sum.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = payload

					case MetricNumberS64:
						payload := (element).Sum.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = payload

					case MetricNumberU64:
						payload := (element).Sum.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice142 := (element).Exemplars
					length144 := uint32(len(slice142))
					result143 := wit_runtime.Allocate(pinner, uintptr(length144*(32+6*4)), 8)
					for index, element := range slice142 {
						base := unsafe.Add(result143, index*(32+6*4))
						slice137 := (element).FilteredAttributes
						length139 := uint32(len(slice137))
						result138 := wit_runtime.Allocate(pinner, uintptr(length139*(4*4)), 4)
						for index, element := range slice137 {
							base := unsafe.Add(result138, index*(4*4))
							utf8135 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8135)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8135)))
							utf8136 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8136)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8136)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length139)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result138)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8140 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8140)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8140)))
						utf8141 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8141)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8141)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (72 + 7*4))) = uint32(length144)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (72 + 6*4))) = uint32(uintptr(uintptr(result143)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length147)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result146)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))

			case MetricDataU64ExponentialHistogram:
				payload := (element).Data.U64ExponentialHistogram()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(7))
				slice165 := (payload).DataPoints
				length167 := uint32(len(slice165))
				result166 := wit_runtime.Allocate(pinner, uintptr(length167*(96+10*4)), 8)
				for index, element := range slice165 {
					base := unsafe.Add(result166, index*(96+10*4))
					slice150 := (element).Attributes
					length152 := uint32(len(slice150))
					result151 := wit_runtime.Allocate(pinner, uintptr(length152*(4*4)), 4)
					for index, element := range slice150 {
						base := unsafe.Add(result151, index*(4*4))
						utf8148 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8148)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8148)))
						utf8149 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8149)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8149)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length152)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result151)))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64((element).Count)

					switch (element).Min.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Min.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Max.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Max.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Sum.Tag() {
					case MetricNumberF64:
						payload := (element).Sum.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Sum.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Sum.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (72 + 2*4))) = int8(int32((element).Scale))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (80 + 2*4))) = int64((element).ZeroCount)
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (88 + 2*4))) = ((element).PositiveBucket).Offset
					data153 := unsafe.Pointer(unsafe.SliceData(((element).PositiveBucket).Counts))
					pinner.Pin(data153)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 4*4))) = uint32(uint32(len(((element).PositiveBucket).Counts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 3*4))) = uint32(uintptr(uintptr(data153)))
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (88 + 5*4))) = ((element).NegativeBucket).Offset
					data154 := unsafe.Pointer(unsafe.SliceData(((element).NegativeBucket).Counts))
					pinner.Pin(data154)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 7*4))) = uint32(uint32(len(((element).NegativeBucket).Counts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 6*4))) = uint32(uintptr(uintptr(data154)))
					*(*float64)(unsafe.Add(unsafe.Pointer(base), (88 + 8*4))) = (element).ZeroThreshold
					slice162 := (element).Exemplars
					length164 := uint32(len(slice162))
					result163 := wit_runtime.Allocate(pinner, uintptr(length164*(32+6*4)), 8)
					for index, element := range slice162 {
						base := unsafe.Add(result163, index*(32+6*4))
						slice157 := (element).FilteredAttributes
						length159 := uint32(len(slice157))
						result158 := wit_runtime.Allocate(pinner, uintptr(length159*(4*4)), 4)
						for index, element := range slice157 {
							base := unsafe.Add(result158, index*(4*4))
							utf8155 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8155)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8155)))
							utf8156 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8156)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8156)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length159)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result158)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8160 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8160)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8160)))
						utf8161 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8161)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8161)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (96 + 9*4))) = uint32(length164)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (96 + 8*4))) = uint32(uintptr(uintptr(result163)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length167)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result166)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))

			case MetricDataS64Gauge:
				payload := (element).Data.S64Gauge()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(8))
				slice183 := (payload).DataPoints
				length185 := uint32(len(slice183))
				result184 := wit_runtime.Allocate(pinner, uintptr(length185*(16+4*4)), 8)
				for index, element := range slice183 {
					base := unsafe.Add(result184, index*(16+4*4))
					slice170 := (element).Attributes
					length172 := uint32(len(slice170))
					result171 := wit_runtime.Allocate(pinner, uintptr(length172*(4*4)), 4)
					for index, element := range slice170 {
						base := unsafe.Add(result171, index*(4*4))
						utf8168 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8168)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8168)))
						utf8169 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8169)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8169)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length172)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result171)))

					switch (element).Value.Tag() {
					case MetricNumberF64:
						payload := (element).Value.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Value.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Value.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice180 := (element).Exemplars
					length182 := uint32(len(slice180))
					result181 := wit_runtime.Allocate(pinner, uintptr(length182*(32+6*4)), 8)
					for index, element := range slice180 {
						base := unsafe.Add(result181, index*(32+6*4))
						slice175 := (element).FilteredAttributes
						length177 := uint32(len(slice175))
						result176 := wit_runtime.Allocate(pinner, uintptr(length177*(4*4)), 4)
						for index, element := range slice175 {
							base := unsafe.Add(result176, index*(4*4))
							utf8173 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8173)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8173)))
							utf8174 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8174)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8174)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length177)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result176)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8178 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8178)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8178)))
						utf8179 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8179)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8179)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length182)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result181)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length185)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result184)))

				switch (payload).StartTime.Tag() {
				case wit_types.OptionNone:
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int8(int32(0))

				case wit_types.OptionSome:
					payload := (payload).StartTime.Some()
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int8(int32(1))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int64((payload).Seconds)
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int32((payload).Nanoseconds)

				default:
					panic("unreachable")
				}
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int32(((payload).Time).Nanoseconds)

			case MetricDataS64Sum:
				payload := (element).Data.S64Sum()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(9))
				slice201 := (payload).DataPoints
				length203 := uint32(len(slice201))
				result202 := wit_runtime.Allocate(pinner, uintptr(length203*(16+4*4)), 8)
				for index, element := range slice201 {
					base := unsafe.Add(result202, index*(16+4*4))
					slice188 := (element).Attributes
					length190 := uint32(len(slice188))
					result189 := wit_runtime.Allocate(pinner, uintptr(length190*(4*4)), 4)
					for index, element := range slice188 {
						base := unsafe.Add(result189, index*(4*4))
						utf8186 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8186)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8186)))
						utf8187 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8187)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8187)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length190)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result189)))

					switch (element).Value.Tag() {
					case MetricNumberF64:
						payload := (element).Value.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Value.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Value.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice198 := (element).Exemplars
					length200 := uint32(len(slice198))
					result199 := wit_runtime.Allocate(pinner, uintptr(length200*(32+6*4)), 8)
					for index, element := range slice198 {
						base := unsafe.Add(result199, index*(32+6*4))
						slice193 := (element).FilteredAttributes
						length195 := uint32(len(slice193))
						result194 := wit_runtime.Allocate(pinner, uintptr(length195*(4*4)), 4)
						for index, element := range slice193 {
							base := unsafe.Add(result194, index*(4*4))
							utf8191 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8191)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8191)))
							utf8192 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8192)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8192)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length195)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result194)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8196 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8196)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8196)))
						utf8197 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8197)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8197)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 3*4))) = uint32(length200)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = uint32(uintptr(uintptr(result199)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length203)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result202)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))
				var result204 int32
				if (payload).IsMonotonic {
					result204 = 1
				} else {
					result204 = 0
				}
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (41 + 8*4))) = int8(result204)

			case MetricDataS64Histogram:
				payload := (element).Data.S64Histogram()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(10))
				slice222 := (payload).DataPoints
				length224 := uint32(len(slice222))
				result223 := wit_runtime.Allocate(pinner, uintptr(length224*(72+8*4)), 8)
				for index, element := range slice222 {
					base := unsafe.Add(result223, index*(72+8*4))
					slice207 := (element).Attributes
					length209 := uint32(len(slice207))
					result208 := wit_runtime.Allocate(pinner, uintptr(length209*(4*4)), 4)
					for index, element := range slice207 {
						base := unsafe.Add(result208, index*(4*4))
						utf8205 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8205)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8205)))
						utf8206 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8206)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8206)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length209)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result208)))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64((element).Count)
					data210 := unsafe.Pointer(unsafe.SliceData((element).Bounds))
					pinner.Pin(data210)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 3*4))) = uint32(uint32(len((element).Bounds)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = uint32(uintptr(uintptr(data210)))
					data211 := unsafe.Pointer(unsafe.SliceData((element).BucketCounts))
					pinner.Pin(data211)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 5*4))) = uint32(uint32(len((element).BucketCounts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 4*4))) = uint32(uintptr(uintptr(data211)))

					switch (element).Min.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Min.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 6*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 6*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Max.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 6*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Max.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 6*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 6*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 6*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Sum.Tag() {
					case MetricNumberF64:
						payload := (element).Sum.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = payload

					case MetricNumberS64:
						payload := (element).Sum.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = payload

					case MetricNumberU64:
						payload := (element).Sum.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 6*4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 6*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					slice219 := (element).Exemplars
					length221 := uint32(len(slice219))
					result220 := wit_runtime.Allocate(pinner, uintptr(length221*(32+6*4)), 8)
					for index, element := range slice219 {
						base := unsafe.Add(result220, index*(32+6*4))
						slice214 := (element).FilteredAttributes
						length216 := uint32(len(slice214))
						result215 := wit_runtime.Allocate(pinner, uintptr(length216*(4*4)), 4)
						for index, element := range slice214 {
							base := unsafe.Add(result215, index*(4*4))
							utf8212 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8212)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8212)))
							utf8213 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8213)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8213)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length216)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result215)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8217 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8217)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8217)))
						utf8218 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8218)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8218)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (72 + 7*4))) = uint32(length221)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (72 + 6*4))) = uint32(uintptr(uintptr(result220)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length224)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result223)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))

			case MetricDataS64ExponentialHistogram:
				payload := (element).Data.S64ExponentialHistogram()
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (6 * 4))) = int8(int32(11))
				slice242 := (payload).DataPoints
				length244 := uint32(len(slice242))
				result243 := wit_runtime.Allocate(pinner, uintptr(length244*(96+10*4)), 8)
				for index, element := range slice242 {
					base := unsafe.Add(result243, index*(96+10*4))
					slice227 := (element).Attributes
					length229 := uint32(len(slice227))
					result228 := wit_runtime.Allocate(pinner, uintptr(length229*(4*4)), 4)
					for index, element := range slice227 {
						base := unsafe.Add(result228, index*(4*4))
						utf8225 := unsafe.Pointer(unsafe.StringData((element).Key))
						pinner.Pin(utf8225)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8225)))
						utf8226 := unsafe.Pointer(unsafe.StringData((element).Value))
						pinner.Pin(utf8226)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8226)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length229)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result228)))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64((element).Count)

					switch (element).Min.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Min.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Max.Tag() {
					case wit_types.OptionNone:
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = int8(int32(0))

					case wit_types.OptionSome:
						payload := (element).Max.Some()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = int8(int32(1))

						switch payload.Tag() {
						case MetricNumberF64:
							payload := payload.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = payload

						case MetricNumberS64:
							payload := payload.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = payload

						case MetricNumberU64:
							payload := payload.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (48 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}

					default:
						panic("unreachable")
					}

					switch (element).Sum.Tag() {
					case MetricNumberF64:
						payload := (element).Sum.F64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(0))
						*(*float64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = payload

					case MetricNumberS64:
						payload := (element).Sum.S64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(1))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = payload

					case MetricNumberU64:
						payload := (element).Sum.U64()
						*(*int8)(unsafe.Add(unsafe.Pointer(base), (56 + 2*4))) = int8(int32(2))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (64 + 2*4))) = int64(payload)

					default:
						panic("unreachable")
					}
					*(*int8)(unsafe.Add(unsafe.Pointer(base), (72 + 2*4))) = int8(int32((element).Scale))
					*(*int64)(unsafe.Add(unsafe.Pointer(base), (80 + 2*4))) = int64((element).ZeroCount)
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (88 + 2*4))) = ((element).PositiveBucket).Offset
					data230 := unsafe.Pointer(unsafe.SliceData(((element).PositiveBucket).Counts))
					pinner.Pin(data230)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 4*4))) = uint32(uint32(len(((element).PositiveBucket).Counts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 3*4))) = uint32(uintptr(uintptr(data230)))
					*(*int32)(unsafe.Add(unsafe.Pointer(base), (88 + 5*4))) = ((element).NegativeBucket).Offset
					data231 := unsafe.Pointer(unsafe.SliceData(((element).NegativeBucket).Counts))
					pinner.Pin(data231)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 7*4))) = uint32(uint32(len(((element).NegativeBucket).Counts)))
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (88 + 6*4))) = uint32(uintptr(uintptr(data231)))
					*(*float64)(unsafe.Add(unsafe.Pointer(base), (88 + 8*4))) = (element).ZeroThreshold
					slice239 := (element).Exemplars
					length241 := uint32(len(slice239))
					result240 := wit_runtime.Allocate(pinner, uintptr(length241*(32+6*4)), 8)
					for index, element := range slice239 {
						base := unsafe.Add(result240, index*(32+6*4))
						slice234 := (element).FilteredAttributes
						length236 := uint32(len(slice234))
						result235 := wit_runtime.Allocate(pinner, uintptr(length236*(4*4)), 4)
						for index, element := range slice234 {
							base := unsafe.Add(result235, index*(4*4))
							utf8232 := unsafe.Pointer(unsafe.StringData((element).Key))
							pinner.Pin(utf8232)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(uint32(len((element).Key)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(utf8232)))
							utf8233 := unsafe.Pointer(unsafe.StringData((element).Value))
							pinner.Pin(utf8233)
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (3 * 4))) = uint32(uint32(len((element).Value)))
							*(*uint32)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = uint32(uintptr(uintptr(utf8233)))

						}

						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 4)) = uint32(length236)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), 0)) = uint32(uintptr(uintptr(result235)))
						*(*int64)(unsafe.Add(unsafe.Pointer(base), (2 * 4))) = int64(((element).Time).Seconds)
						*(*int32)(unsafe.Add(unsafe.Pointer(base), (8 + 2*4))) = int32(((element).Time).Nanoseconds)

						switch (element).Value.Tag() {
						case MetricNumberF64:
							payload := (element).Value.F64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(0))
							*(*float64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberS64:
							payload := (element).Value.S64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(1))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = payload

						case MetricNumberU64:
							payload := (element).Value.U64()
							*(*int8)(unsafe.Add(unsafe.Pointer(base), (16 + 2*4))) = int8(int32(2))
							*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 2*4))) = int64(payload)

						default:
							panic("unreachable")
						}
						utf8237 := unsafe.Pointer(unsafe.StringData((element).SpanId))
						pinner.Pin(utf8237)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 3*4))) = uint32(uint32(len((element).SpanId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 2*4))) = uint32(uintptr(uintptr(utf8237)))
						utf8238 := unsafe.Pointer(unsafe.StringData((element).TraceId))
						pinner.Pin(utf8238)
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 5*4))) = uint32(uint32(len((element).TraceId)))
						*(*uint32)(unsafe.Add(unsafe.Pointer(base), (32 + 4*4))) = uint32(uintptr(uintptr(utf8238)))

					}

					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (96 + 9*4))) = uint32(length241)
					*(*uint32)(unsafe.Add(unsafe.Pointer(base), (96 + 8*4))) = uint32(uintptr(uintptr(result240)))

				}

				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 7*4))) = uint32(length244)
				*(*uint32)(unsafe.Add(unsafe.Pointer(base), (8 + 6*4))) = uint32(uintptr(uintptr(result243)))
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (8 + 8*4))) = int64(((payload).StartTime).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (16 + 8*4))) = int32(((payload).StartTime).Nanoseconds)
				*(*int64)(unsafe.Add(unsafe.Pointer(base), (24 + 8*4))) = int64(((payload).Time).Seconds)
				*(*int32)(unsafe.Add(unsafe.Pointer(base), (32 + 8*4))) = int32(((payload).Time).Nanoseconds)
				*(*int8)(unsafe.Add(unsafe.Pointer(base), (40 + 8*4))) = int8(int32((payload).Temporality))

			default:
				panic("unreachable")
			}

		}

		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (11 * 4))) = uint32(length247)
		*(*uint32)(unsafe.Add(unsafe.Pointer(base), (10 * 4))) = uint32(uintptr(uintptr(result246)))

	}

	wasm_import_export(uintptr(result), length, option, option2, option3, uintptr(result249), length250, returnArea)
	var result251 wit_types.Result[wit_types.Unit, string]
	switch uint8(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 0))) {
	case 0:

		result251 = wit_types.Ok[wit_types.Unit, string](wit_types.Unit{})
	case 1:
		value := unsafe.String((*uint8)(unsafe.Pointer(uintptr(*(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), 4))))), *(*uint32)(unsafe.Add(unsafe.Pointer(returnArea), (2 * 4))))

		result251 = wit_types.Err[wit_types.Unit, string](value)
	default:
		panic("unreachable")
	}
	result252 := result251
	return result252

}
